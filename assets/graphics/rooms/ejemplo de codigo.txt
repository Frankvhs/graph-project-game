```
SISTEMA DE GENERACIÓN DE MAZMORRAS PARA LIBGDX

CLASES PRINCIPALES:

1. Room.java - Representa una habitación
2. DungeonGenerator.java - Genera el grafo del nivel
3. GameScreen.java - Maneja el ciclo del juego

IMPLEMENTACIÓN:

==================== Room.java ====================
public class Room {
    public enum Door { NORTH, SOUTH, EAST, WEST, NONE }
    public enum RoomType { 
        ONE_DOOR, TWO_DOORS, THREE_DOORS, FOUR_DOORS 
    }
    
    public Array<Door> doors;
    public RoomType type;
    public boolean hasStair;
    public int gridX, gridY;
    public String textureName;
    
    public Room(RoomType type, Array<Door> doors) {
        this.type = type;
        this.doors = doors;
        this.hasStair = false;
    }
}

==================== DungeonGenerator.java ====================
public class DungeonGenerator {
    private Array<Room> rooms;
    private Array<Door> unconnectedDoors;
    private int currentLevel;
    
    // Configuración por nivel
    private LevelConfig getLevelConfig(int level) {
        LevelConfig config = new LevelConfig();
        config.maxRooms = 4 + (level * 2);
        config.prob1Door = Math.max(0.1f, 0.6f - (level * 0.1f));
        config.prob4Doors = Math.min(0.4f, 0.0f + (level * 0.05f));
        return config;
    }
    
    // GENERAR NUEVO NIVEL (llamar esto al pasar de nivel)
    public Array<Room> generateNewLevel(int level) {
        // LIMPIAR DATOS ANTERIORES
        clearPreviousLevel();
        
        this.currentLevel = level;
        LevelConfig config = getLevelConfig(level);
        
        // 1. CREAR HABITACIÓN INICIAL
        Room startRoom = createStartRoom(level);
        rooms.add(startRoom);
        addUnconnectedDoors(startRoom);
        
        // 2. EXPANDIR
        while (rooms.size < config.maxRooms && unconnectedDoors.size > 0) {
            expandDungeon(config);
        }
        
        // 3. COLOCAR ESCALERA
        placeStair();
        
        return rooms;
    }
    
    // LIMPIAR NIVEL ANTERIOR
    private void clearPreviousLevel() {
        if (rooms != null) rooms.clear();
        if (unconnectedDoors != null) unconnectedDoors.clear();
        
        rooms = new Array<Room>();
        unconnectedDoors = new Array<Door>();
        
        // Forzar garbage collection
        Gdx.app.postRunnable(new Runnable() {
            @Override
            public void run() {
                System.gc();
            }
        });
    }
    
    private Room createStartRoom(int level) {
        if (level == 1) {
            return createRoomWithType(RoomType.ONE_DOOR);
        } else {
            // Aleatorio según dificultad
            RoomType[] types = {RoomType.ONE_DOOR, RoomType.TWO_DOORS, RoomType.THREE_DOORS};
            return createRoomWithType(types[MathUtils.random(types.length-1)]);
        }
    }
    
    private void expandDungeon(LevelConfig config) {
        if (unconnectedDoors.size == 0) return;
        
        Door doorToConnect = unconnectedDoors.first();
        unconnectedDoors.removeValue(doorToConnect, true);
        
        Room newRoom = findCompatibleRoom(doorToConnect, config);
        if (newRoom != null) {
            rooms.add(newRoom);
            addUnconnectedDoors(newRoom);
        }
    }
    
    private Room findCompatibleRoom(Door targetDoor, LevelConfig config) {
        Door requiredDoor = getOppositeDoor(targetDoor);
        Array<Room> compatibleRooms = getPredefinedRooms();
        
        // Filtrar por probabilidades del nivel
        compatibleRooms = filterByLevelConfig(compatibleRooms, config);
        
        return compatibleRooms.size > 0 ? 
               compatibleRooms.get(MathUtils.random(compatibleRooms.size-1)) : null;
    }
    
    private void placeStair() {
        // Encontrar habitación más alejada del inicio
        Room farthestRoom = findFarthestRoom();
        farthestRoom.hasStair = true;
    }
    
    private Room findFarthestRoom() {
        // Lógica para encontrar habitación más lejana
        return rooms.get(rooms.size - 1); // Simplificado
    }
}

==================== GameScreen.java ====================
public class GameScreen implements Screen {
    private DungeonGenerator dungeonGenerator;
    private Array<Room> currentRooms;
    private int currentLevel;
    
    @Override
    public void show() {
        dungeonGenerator = new DungeonGenerator();
        currentLevel = 1;
        startNewLevel();
    }
    
    private void startNewLevel() {
        // GENERAR NUEVO NIVEL (esto limpia automáticamente el anterior)
        currentRooms = dungeonGenerator.generateNewLevel(currentLevel);
        
        // Cargar texturas para las nuevas habitaciones
        loadRoomTextures();
        
        // Reiniciar posición del jugador en la primera habitación
        resetPlayerPosition();
    }
    
    public void goToNextLevel() {
        currentLevel++;
        startNewLevel(); // Esto limpia y genera nuevo nivel automáticamente
    }
    
    private void loadRoomTextures() {
        // LibGDX: Cargar texturas para cada habitación
        for (Room room : currentRooms) {
            room.textureName = "room_" + room.type.toString().toLowerCase() + ".png";
            // AssetManager.load() etc...
        }
    }
    
    private void resetPlayerPosition() {
        // Posicionar jugador en la habitación inicial
        Room startRoom = currentRooms.first();
        player.setPosition(startRoom.gridX, startRoom.gridY);
    }
    
    @Override
    public void render(float delta) {
        // Dibujar habitaciones actuales
        for (Room room : currentRooms) {
            drawRoom(room);
        }
    }
    
    @Override
    public void dispose() {
        // LIMPIAR TODO al cerrar el juego
        if (currentRooms != null) currentRooms.clear();
        dungeonGenerator = null;
    }
}

==================== USO ====================
// Al colisionar con la escalera:
public void onStairCollision() {
    goToNextLevel(); // Esto genera automáticamente nuevo nivel limpio
}

==================== LEVEL CONFIG ====================
class LevelConfig {
    public int maxRooms;
    public float prob1Door;
    public float prob4Doors;
}

CARACTERÍSTICAS LIBGDX:
- Array<> instead of ArrayList (mejor performance)
- MathUtils.random() para aleatoriedad
- Gdx.app.postRunnable() para garbage collection
- AssetManager para gestión de texturas
- Dispose pattern para limpieza de recursos

VENTAJAS:
✅ Cada nivel es completamente nuevo
✅ No hay memory leaks
✅ Fácil de depurar
✅ Escalable para niveles infinitos
✅ Usa mejores prácticas de LibGDX
```